<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Photo Organizer</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .album-suggestions {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background-color: #2a2a2a;
        }

        .album-button {
            flex: 1;
            max-width: 300px;
            padding: 15px 20px;
            background-color: #3a3a3a;
            border: 2px solid #555;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .album-button:hover {
            background-color: #4a4a4a;
            border-color: #777;
        }

        .album-button h3 {
            margin: 0;
            font-size: 18px;
        }

        .photo-display {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #1a1a1a;
            overflow: hidden;
        }

        .photo-container {
            max-width: 80%;
            max-height: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .photo-container img {
            max-width: 100%;
            max-height: calc(100vh - 340px); /* Account for album suggestions (~120px), photo info (60px), rescan button (~40px), filmstrip (120px) */
            min-height: 200px; /* Minimum photo size */
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .photo-info {
            margin-top: 10px;
            text-align: center;
            max-width: 600px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-shrink: 0;
        }

        .photo-info h2 {
            margin-bottom: 8px;
            font-size: 20px;
        }

        .photo-info .meta {
            font-size: 14px;
            opacity: 0.7;
            margin-bottom: 10px;
        }

        .photo-info .description {
            font-size: 16px;
            line-height: 1.4;
        }

        .nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0,0,0,0.7);
            border: none;
            color: white;
            font-size: 24px;
            padding: 15px 20px;
            cursor: pointer;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        .nav-button:hover {
            background-color: rgba(0,0,0,0.9);
        }

        .nav-button.prev {
            left: 20px;
        }

        .nav-button.next {
            right: 20px;
        }

        .filmstrip {
            height: 120px;
            background-color: #2a2a2a;
            display: flex;
            align-items: center;
            padding: 10px;
            overflow-x: auto;
            overflow-y: hidden;
            gap: 10px;
            flex-shrink: 0;
        }

        .filmstrip::-webkit-scrollbar {
            height: 8px;
        }

        .filmstrip::-webkit-scrollbar-track {
            background-color: #1a1a1a;
        }

        .filmstrip::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 4px;
        }

        .thumbnail {
            height: 100px;
            width: 100px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            flex-shrink: 0;
        }

        .thumbnail:hover {
            transform: scale(1.05);
        }

        .thumbnail.active {
            border-color: #4CAF50;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            align-self: flex-start;
            margin-left: 20px;
            margin-bottom: 10px;
        }

        .action-button {
            background-color: #2e7d32; /* Dark green */
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        .action-button:hover {
            background-color: #1b5e20;
        }

        .action-button.secondary {
            background-color: #FF9800; /* Orange */
        }

        .action-button.secondary:hover {
            background-color: #F57C00;
        }

        .action-button.tertiary {
            background-color: #9C27B0; /* Purple */
        }

        .action-button.tertiary:hover {
            background-color: #7B1FA2;
        }

        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .progress-content {
            background-color: #2a2a2a;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #1a1a1a;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
        }

        .no-photos {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            opacity: 0.7;
        }

        .suggestions-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 20px;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #555;
            border-top: 3px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        .error-summary {
            background-color: #2a2a2a;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 20px;
            margin: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .error-summary h3 {
            color: #f44336;
            margin-bottom: 15px;
        }

        .error-list {
            background-color: #1a1a1a;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .error-item {
            margin-bottom: 8px;
            font-size: 14px;
            color: #ffcccb;
        }

        .success-message {
            color: #4CAF50;
            font-weight: bold;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        function App() {
            const [photos, setPhotos] = useState([]);
            const [currentPhotoIndex, setCurrentPhotoIndex] = useState(0);
            const [suggestions, setSuggestions] = useState([]);
            const [suggestionsLoading, setSuggestionsLoading] = useState(false);
            const [suggestionsCache, setSuggestionsCache] = useState(new Map());
            const [loadingStates, setLoadingStates] = useState(new Map());
            const [preloadQueue, setPreloadQueue] = useState([]);
            const [isPreloading, setIsPreloading] = useState(false);
            const [loading, setLoading] = useState(true);
            const [progress, setProgress] = useState(null);
            const [completionResult, setCompletionResult] = useState(null);
            const [ws, setWs] = useState(null);
            const currentPhoto = photos[currentPhotoIndex];

            useEffect(() => {
                loadPhotos();
                initWebSocket();
            }, []);

            useEffect(() => {
                if (currentPhoto) {
                    // Update loading state for current photo
                    setSuggestionsLoading(loadingStates.get(currentPhoto.id) || false);
                    
                    // Check if we have cached suggestions for this photo
                    if (suggestionsCache.has(currentPhoto.id)) {
                        setSuggestions(suggestionsCache.get(currentPhoto.id));
                    } else {
                        setSuggestions([]); // Clear suggestions until new ones load
                        loadSuggestions(currentPhoto.id);
                    }
                } else {
                    setSuggestions([]);
                    setSuggestionsLoading(false);
                }
            }, [currentPhoto]);

            // Preload suggestions when current photo changes
            useEffect(() => {
                if (photos.length > 0 && currentPhotoIndex >= 0) {
                    queueSurroundingPreloads(currentPhotoIndex);
                }
            }, [currentPhotoIndex, photos.length]);

            // Add keyboard navigation
            useEffect(() => {
                const handleKeyDown = (event) => {
                    // Only handle arrow keys when not typing in an input field
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    
                    switch (event.key) {
                        case 'ArrowLeft':
                            event.preventDefault();
                            if (currentPhotoIndex > 0) {
                                setCurrentPhotoIndex(currentPhotoIndex - 1);
                            }
                            break;
                        case 'ArrowRight':
                            event.preventDefault();
                            if (currentPhotoIndex < photos.length - 1) {
                                setCurrentPhotoIndex(currentPhotoIndex + 1);
                            }
                            break;
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                
                // Cleanup event listener on unmount
                return () => {
                    document.removeEventListener('keydown', handleKeyDown);
                };
            }, [currentPhotoIndex, photos.length]);

            const initWebSocket = () => {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                const websocket = new WebSocket(wsUrl);

                websocket.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    
                    switch (message.type) {
                        case 'progress':
                            setProgress(message.payload);
                            setCompletionResult(null);
                            break;
                        case 'complete':
                            setProgress(null);
                            setCompletionResult(message.payload);
                            loadPhotos();
                            break;
                        case 'error':
                            console.error('WebSocket error:', message.payload.error);
                            setProgress(null);
                            setCompletionResult({
                                message: 'Operation failed: ' + message.payload.error,
                                errors: { photo_errors: [], album_errors: [message.payload.error], total_errors: 1 }
                            });
                            break;
                    }
                };

                setWs(websocket);
            };

            const loadPhotos = async () => {
                try {
                    console.log('Fetching photos from:', window.location.origin + '/api/photos/unsorted');
                    const response = await fetch('/api/photos/unsorted');
                    console.log('Response status:', response.status);
                    console.log('Response headers:', response.headers);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('Photos data:', data);
                    setPhotos(data || []);
                    setLoading(false);
                } catch (error) {
                    console.error('Error loading photos:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        name: error.name
                    });
                    setLoading(false);
                }
            };

            const loadSuggestions = async (photoId, isPriority = true) => {
                // Check cache first
                if (suggestionsCache.has(photoId)) {
                    // Get current photo ID at time of execution, not closure time
                    const currentPhotoId = photos[currentPhotoIndex]?.id;
                    if (currentPhotoId === photoId) {
                        setSuggestionsLoading(false);
                        setSuggestions(suggestionsCache.get(photoId));
                    }
                    return;
                }

                // Check if already loading this photo to prevent duplicate requests
                if (loadingStates.get(photoId)) {
                    // If this is for the current photo, make sure loading state is shown
                    const currentPhotoId = photos[currentPhotoIndex]?.id;
                    if (currentPhotoId === photoId) {
                        setSuggestionsLoading(true);
                    }
                    return;
                }

                // If this is a priority request (current photo), remove it from preload queue
                if (isPriority) {
                    setPreloadQueue(prev => prev.filter(item => item.id !== photoId));
                }

                // Set loading state for this photo
                setLoadingStates(prev => new Map(prev).set(photoId, true));
                
                // Check if this is for the current photo and set UI loading state
                const currentPhotoId = photos[currentPhotoIndex]?.id;
                if (currentPhotoId === photoId) {
                    setSuggestionsLoading(true);
                }

                try {
                    const response = await fetch(`/api/photos/suggestions?photo_id=${photoId}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const suggestions = data.albums || [];
                    
                    // Always cache the response for this photo
                    setSuggestionsCache(prev => new Map(prev).set(photoId, suggestions));
                    
                    // Only update UI if this is still the current photo (check again at response time)
                    const finalCurrentPhotoId = photos[currentPhotoIndex]?.id;
                    if (finalCurrentPhotoId === photoId) {
                        setSuggestions(suggestions);
                        setSuggestionsLoading(false);
                    }
                } catch (error) {
                    console.error(`Error loading suggestions for photo ${photoId}:`, error);
                    
                    // Only update UI if this is still the current photo
                    const finalCurrentPhotoId = photos[currentPhotoIndex]?.id;
                    if (finalCurrentPhotoId === photoId) {
                        setSuggestions([]);
                        setSuggestionsLoading(false);
                    }
                } finally {
                    // Always clear loading state for this photo
                    setLoadingStates(prev => new Map(prev).set(photoId, false));
                    
                    // If this was a preload request, trigger the next one
                    if (!isPriority) {
                        processNextPreload();
                    }
                }
            };

            const processNextPreload = () => {
                if (isPreloading) {
                    return; // Already processing
                }
                
                setPreloadQueue(prev => {
                    if (prev.length === 0) {
                        return prev;
                    }
                    
                    const [nextItem, ...remaining] = prev;
                    
                    // Check if still needed (might have been cached or loaded elsewhere)
                    if (!suggestionsCache.has(nextItem.id) && !loadingStates.get(nextItem.id)) {
                        setIsPreloading(true);
                        loadSuggestions(nextItem.id, false).finally(() => {
                            setIsPreloading(false);
                            // Process next item in queue after this one completes
                            setTimeout(() => processNextPreload(), 0);
                        });
                    } else {
                        // Item no longer needed, skip to next
                        setTimeout(() => processNextPreload(), 0);
                    }
                    
                    return remaining;
                });
            };

            const queueSurroundingPreloads = (centerIndex) => {
                // Validate center index
                if (centerIndex < 0 || centerIndex >= photos.length) {
                    return;
                }
                
                // Get photos in range: 2 to left, 4 to right
                const leftStart = Math.max(0, centerIndex - 2);
                const rightEnd = Math.min(photos.length, centerIndex + 5); // +5 because centerIndex + 4 inclusive
                
                const photosToQueue = [];
                const seenIds = new Set();
                
                // Add photos to the left (excluding center)
                for (let i = leftStart; i < centerIndex; i++) {
                    const photo = photos[i];
                    if (photo && 
                        !seenIds.has(photo.id) &&
                        !suggestionsCache.has(photo.id) && 
                        !loadingStates.get(photo.id)) {
                        seenIds.add(photo.id);
                        photosToQueue.push({
                            id: photo.id,
                            index: i,
                            distance: centerIndex - i // For prioritization
                        });
                    }
                }
                
                // Add photos to the right (excluding center)
                for (let i = centerIndex + 1; i < rightEnd; i++) {
                    const photo = photos[i];
                    if (photo && 
                        !seenIds.has(photo.id) &&
                        !suggestionsCache.has(photo.id) && 
                        !loadingStates.get(photo.id)) {
                        seenIds.add(photo.id);
                        photosToQueue.push({
                            id: photo.id,
                            index: i,
                            distance: i - centerIndex // For prioritization
                        });
                    }
                }
                
                // Sort by distance (closer photos get priority)
                photosToQueue.sort((a, b) => a.distance - b.distance);
                
                // Update the queue, removing any existing items that are in the new list
                // and ensuring no duplicates
                setPreloadQueue(prev => {
                    const newIds = new Set(photosToQueue.map(p => p.id));
                    const filteredPrev = prev.filter(item => !newIds.has(item.id));
                    return [...photosToQueue, ...filteredPrev];
                });
                
                // Start processing if not already in progress
                if (!isPreloading && photosToQueue.length > 0) {
                    processNextPreload();
                }
                
                if (photosToQueue.length > 0) {
                    console.log(`Queued ${photosToQueue.length} photos for preloading around index ${centerIndex}`);
                }
            };

            const movePhoto = async (albumId) => {
                if (!currentPhoto) return;

                const photoIdToMove = currentPhoto.id;

                try {
                    const response = await fetch('/api/photos/move', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            photo_id: photoIdToMove,
                            album_id: albumId,
                        }),
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    // Clean up state for the moved photo
                    setSuggestionsCache(prev => {
                        const newCache = new Map(prev);
                        newCache.delete(photoIdToMove);
                        return newCache;
                    });
                    setLoadingStates(prev => {
                        const newStates = new Map(prev);
                        newStates.delete(photoIdToMove);
                        return newStates;
                    });
                    setPreloadQueue(prev => prev.filter(item => item.id !== photoIdToMove));
                    
                    // Remove photo from list
                    const newPhotos = photos.filter(p => p.id !== photoIdToMove);
                    setPhotos(newPhotos);
                    
                    // Adjust current index if necessary
                    if (currentPhotoIndex >= newPhotos.length && newPhotos.length > 0) {
                        setCurrentPhotoIndex(newPhotos.length - 1);
                    } else if (newPhotos.length === 0) {
                        setCurrentPhotoIndex(0);
                        setSuggestions([]);
                        setSuggestionsLoading(false);
                    }
                } catch (error) {
                    console.error(`Error moving photo ${photoIdToMove}:`, error);
                    // Could show user-facing error message here
                }
            };

            const nextPhoto = () => {
                if (currentPhotoIndex < photos.length - 1) {
                    setCurrentPhotoIndex(currentPhotoIndex + 1);
                }
            };

            const prevPhoto = () => {
                if (currentPhotoIndex > 0) {
                    setCurrentPhotoIndex(currentPhotoIndex - 1);
                }
            };

            const startOperation = (operationType) => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: operationType }));
                }
            };

            const startDescribePhotos = () => startOperation('describe_photos');
            const startDescribeAllAlbums = () => startOperation('describe_all_albums');
            const startRetryAlbumFailures = () => startOperation('retry_album_failures');


            if (progress) {
                const progressPercent = progress.total > 0 ? (progress.current / progress.total) * 100 : 0;
                
                return (
                    <div className="progress-overlay">
                        <div className="progress-content">
                            <h2>Processing AI Descriptions</h2>
                            <p>{progress.description}</p>
                            <div className="progress-bar">
                                <div className="progress-fill" style={{width: `${progressPercent}%`}}></div>
                            </div>
                            <p>{progress.current} of {progress.total} items processed</p>
                            {progress.stage && <p>Stage: {progress.stage}</p>}
                        </div>
                    </div>
                );
            }

            if (completionResult) {
                const hasErrors = completionResult.errors && completionResult.errors.total_errors > 0;
                
                return (
                    <div className="progress-overlay">
                        <div className="progress-content">
                            <h2>Operation Complete</h2>
                            <p className="success-message">{completionResult.message}</p>
                            
                            {hasErrors && (
                                <div className="error-summary">
                                    <h3>Errors Encountered ({completionResult.errors.total_errors})</h3>
                                    
                                    {completionResult.errors.photo_errors && completionResult.errors.photo_errors.length > 0 && (
                                        <div>
                                            <h4>Photo Errors:</h4>
                                            <div className="error-list">
                                                {completionResult.errors.photo_errors.map((error, index) => (
                                                    <div key={index} className="error-item">{error}</div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    
                                    {completionResult.errors.album_errors && completionResult.errors.album_errors.length > 0 && (
                                        <div>
                                            <h4>Album Errors:</h4>
                                            <div className="error-list">
                                                {completionResult.errors.album_errors.map((error, index) => (
                                                    <div key={index} className="error-item">{error}</div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}
                            
                            <button 
                                className="action-button" 
                                onClick={() => setCompletionResult(null)}
                                style={{marginTop: '20px'}}
                            >
                                Close
                            </button>
                        </div>
                    </div>
                );
            }

            if (loading) {
                return <div className="loading">Loading photos...</div>;
            }

            if (photos.length === 0) {
                return <div className="no-photos">No unsorted photos found!</div>;
            }

            return (
                <div className="app">
                    <div className="main-content">
                        <div className="album-suggestions">
                            {suggestionsLoading ? (
                                <div className="suggestions-loading">
                                    <div className="spinner"></div>
                                    <span>Loading album suggestions...</span>
                                </div>
                            ) : (
                                suggestions.map((album, index) => (
                                    <button 
                                        key={album.id} 
                                        className="album-button"
                                        onClick={() => movePhoto(album.id)}
                                    >
                                        <h3>{album.name}</h3>
                                    </button>
                                ))
                            )}
                        </div>

                        <div className="photo-display">
                            {currentPhoto && (
                                <>
                                    <div className="photo-container">
                                        <img 
                                            src={currentPhoto.full_size} 
                                            alt={currentPhoto.title}
                                            loading="lazy"
                                        />
                                        <div className="photo-info">
                                            <h2>{currentPhoto.title}</h2>
                                            <div className="meta">Taken: {currentPhoto.taken_at}</div>
                                        </div>
                                    </div>

                                    <button 
                                        className="nav-button prev" 
                                        onClick={prevPhoto}
                                        disabled={currentPhotoIndex === 0}
                                    >
                                        ‹
                                    </button>
                                    <button 
                                        className="nav-button next" 
                                        onClick={nextPhoto}
                                        disabled={currentPhotoIndex === photos.length - 1}
                                    >
                                        ›
                                    </button>
                                </>
                            )}
                        </div>
                    </div>

                    <div className="action-buttons">
                        <button className="action-button" onClick={startDescribePhotos}>
                            Describe Photos
                        </button>
                        <button className="action-button secondary" onClick={startDescribeAllAlbums}>
                            Describe All Albums
                        </button>
                        <button className="action-button tertiary" onClick={startRetryAlbumFailures}>
                            Retry Album Failures
                        </button>
                    </div>

                    <div className="filmstrip">
                        {photos.map((photo, index) => (
                            <img
                                key={photo.id}
                                src={photo.thumbnail}
                                alt={photo.title}
                                className={`thumbnail ${index === currentPhotoIndex ? 'active' : ''}`}
                                onClick={() => setCurrentPhotoIndex(index)}
                                loading="lazy"
                            />
                        ))}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>